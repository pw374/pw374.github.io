%% Copyright (C) 2013  Philippe Wang -*- coding: utf-8 -*-
{< module Meta : Meta = struct
 let title = "Functional visitors"
 let id = "posts/2014-01-06-09-24-25-functional-visitors.html"
 let xmldate = "2014-01-06T09:24:25+00:00"
 let xmldate_updated = xmldate
 let rssdate = "Mon, 06 Jan 2014 09:24:25 +0000"
 let date = "2014-01-06 09:24:25+00:00"
 let tags = [ "ocaml" ]
 let disqus = true
 let stamp = true
 let tryocaml = false
end
include Meta

module Post(Printer:Printer) = struct open Printer >}

Let's consider this data type:
```ocaml
type e = | A | B of t | C of string * t * t | D of string | E of int
and  t = e list
```

If we want to write an abstraction to apply a function to this 
data structure (the one of type t)
without being bothered to treat the whole structure everytime,
we can get some inspiration from the visitor design pattern commonly used
in object-oriented programming. The “problem” is that we don't have the 
same inheritance mechanism in functional programming, meaning that the default
behaviour has to be implemented with functions instead of using methods
that can be overriden in subclasses.

Let us have this first attempt:

```ocaml
let rec visit f = function
  | [] -> []
  | (A | E _ | D _) as e :: tl ->
    begin match f e with
      | Some(l) -> l @ visit f tl
      | None -> e :: visit f tl
    end
  | B(t) as e :: tl ->
    begin match f e with
      | Some(l) -> l @ visit f tl
      | None -> B(visit f t) :: visit f tl
    end
  | C(s, t1, t2) as e :: tl ->
    begin match f e with
      | Some(l) -> l @ visit f tl
      | None -> C(s, visit f t1, visit f t2) :: visit f tl
    end
(* val visit : (e -> t option) -> t -> t *)
```

With this abstraction, it becomes very easy to write a function
that removes all `A`s:

```ocaml
let remove_A t = visit (function A -> Some [] | _ -> None) t
```

or all `B`s:

```ocaml
let remove_B t = visit (function B _ -> Some [] | _ -> None) t
```

and it's also very easy to convert all `E`s to `D`s:

```ocaml
let convert_Es_to_Ds t =
  visit (function E(i) -> Some [D(string_of_int i)] | _ -> None) t
```

Well, perhaps we might want to have a visitor that doesn't always 
return a `t`. Can we make it generic using polymorphic abstractions?
The implementation of `visit` returns a value, so if we want it to 
be able to return something else, we have to parameterise the default
behaviour.

So, let's add a parameter to the function `visit` and see what it looks like.

```ocaml
let rec visit f default = function
  | [] -> []
  | (A | E _ | D _) as e :: tl ->
    begin match f e with
      | Some(l) -> default l (visit f default tl)
      | None -> default [] (e :: visit f default tl)
    end
  | B(t) as e :: tl ->
    begin match f e with
      | Some(l) -> default l (visit f default tl)
      | None -> default [] (B(visit f default t) :: visit f default tl)
    end
  | C(s, t1, t2) as e :: tl ->
    begin match f e with
      | Some(l) -> default l (visit f default tl)
      | None ->
        default []
          (C(s, visit f default t1, visit f default t2) :: visit f default tl)
    end
(* val visit : (e -> 'a list option) -> ('a list -> t -> t) -> t -> t *)
```

We're almost there. There's still that `'a list`, which is less generic
than `'a`. Well, `default` needs to have 2 parameters because it has to
be able to treat both branches of the pattern-matching filter, so we could 
make the first parameter optional. We could use optional arguments, and
we can see that `f` already returns an option, 
can we just take advantage of that? Well, if we replace for instance
```ocaml
  | (A | E _ | D _) as e :: tl ->
    begin match f e with
      | Some(l) -> default l (visit f default tl)
      | None -> default [] (e :: visit f default tl)
    end
```
by
```ocaml
  | (A | E _ | D _) as e :: tl ->
      default (f e) (visit f default tl)
```
it does work for this branch but it doesn't for the others because
one purpose of the visitor is to deeply traverse the
data structure automatically.
So we're back to optional arguments...

And so we could have that:
```ocaml
let rec visit f ?(default=(fun ?l r -> match l with None -> r | Some l -> l @ r)) = function
  | [] -> []
  | (A | E _ | D _) as e :: tl ->
    begin match f e with
      | Some(l) -> default ~l (visit f ~default tl)
      | None -> default (e :: visit f ~default tl)
    end
  | B(t) as e :: tl ->
    begin match f e with
      | Some(l) -> default ~l (visit f ~default tl)
      | None -> default (B(visit f ~default t) :: visit f ~default tl)
    end
  | C(s, t1, t2) as e :: tl ->
    begin match f e with
      | Some(l) -> default ~l (visit f ~default tl)
      | None ->
        default 
          (C(s, visit f ~default t1, visit f ~default t2) :: visit f ~default tl)
    end
;;
(* val visit : (e -> t option) -> ?default:(?l:t -> t -> t) -> t -> t *)
```

Then the problem is that it's not polymorphic any more, while we want it to be polymorphic!

```ocaml
let rec visit f (default:(?l:'a -> t -> t)) = function
  | [] -> []
  | (A | E _ | D _) as e :: tl ->
    begin match f e with
      | Some(l) -> default ~l (visit f default tl)
      | None -> default (e :: visit f default tl)
    end
  | B(t) as e :: tl ->
    begin match f e with
      | Some(l) -> default ~l (visit f default tl)
      | None -> default (B(visit f default t) :: visit f default tl)
    end
  | C(s, t1, t2) as e :: tl ->
    begin match f e with
      | Some(l) -> default ~l (visit f default tl)
      | None ->
        default 
          (C(s, visit f default t1, visit f default t2) :: visit f default tl)
    end
;;
(* val visit : (e -> 'a option) -> (?l:'a -> t -> t) -> t -> t *)

```






{< end >}%% don't write anything after this line
